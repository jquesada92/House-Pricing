---
title: 'HarvardX PH125.9xData Science: Capstone Choose Your Own!(House Pricing)'
author: "Jose Quesada"
date: "27/12/2020"
output: pdf_document
---
```{r, echo=TRUE, message=FALSE, warning=FALSE, include=FALSE}
options(warn=-1)
options(tidyverse.quiet = TRUE)
if(!require(tidyverse, warn.conflicts = FALSE)) install.packages("tidyverse", repos = "http://cran.us.r-project.org")
if(!require(caret)) install.packages("caret", repos = "http://cran.us.r-project.org")
if(!require(data.table)) install.packages("data.table", repos = "http://cran.us.r-project.org")
if(!require(lubridate)) install.packages("lubridate")
if(!require(devtools)) install.packages("devtools")
if(!require(gridExtra)) install.packages("gridExtra")
if(!require(kableExtra)) install.packages("kableExtra")
if(!require(ggraph)) install.packages("ggraph")
if(!require(igraph)) install.packages("igraph")
```

```{r, echo=TRUE, message=FALSE, warning=FALSE, include=FALSE}
library(tidyverse, warn.conflicts = FALSE)
library(caret)
library(data.table)
library(lubridate)
library(devtools)
library(gridExtra)
library(kableExtra) 
library(plyr)
library(Matrix)
options(tinytex.verbose = TRUE)

#updating default size text of ggplots
update_geom_defaults("text", list(size = 16))

#Converting Markdown to R script.
knitr::purl("HousePricing.Rmd")

# Suppress summarise info
options(dplyr.summarise.inform = FALSE)



#mode function get most frequent value.
mode<- function(x){
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]}



#Label_quality_Conditions encoder.
Quac_Cond_decoder <- function(df,col){
evaluation_quality <- data.table("quality" = c("Po","Fa","TA","Gd","Ex"), "score"=c(1,2,3,4,5))
mapvalues(as.vector(df[,col]),evaluation_quality$quality,evaluation_quality$score)}
```
# Introduccion 


This project consists of determining the value of a house according to its location, property characteristics and payment methods using the data set from kaggle House Prices - Advanced Regression Techniques https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data (kaggle competitions download -c house-prices-advanced-regression-techniques).


# Importing Data.


Files:

    train.csv - the training set
    test.csv - the test set
    data_description.txt - full description of each column, originally prepared by Dean De Cock but lightly edited to match the column names used here
    sample_submission.csv - a benchmark submission from a linear regression on year and month of sale, lot square footage, and number of bedrooms

 
```{r}
read_csv <- function(file){
    path_data <- "data"
    filename <- paste(path_data,file,sep="/")
    csv__ <- read.csv(filename)
    csv__
}

test_set <-read_csv('test.csv')
train_set<- read_csv('train.csv')


#Join datasets, For this project we going to join train and set data for the cleansing and EDA, later we going to split again by SalesPrices not null as train set and test set is null.
df<- bind_rows(train_set,test_set)
```


```{r, echo=FALSE,warning=FALSE,message=FALSE}


#Train SET INFO
colnames_trian_set<-colnames(train_set)
memory_usage_train_set<-format(object.size(train_set),units="MB")
dim_train_set<- dim(train_set)

#TEST SET INFO
colnames_test_set<-colnames(test_set)
memory_usage_test_set<-format(object.size(test_set),units="MB")
dim_test_set <- dim(test_set)
```


# EDA

train_set:

    * Dimensions: `r toString(dim_train_set)`
    * Memory Usage: `r toString(memory_usage_train_set)`

test_set:

    * Dimensions: `r toString(dim_test_set)`
    * Memory Usage: `r toString(memory_usage_test_set)`
    

```{r, echo=FALSE,  message=FALSE, warning=FALSE}

#searching for the additional column in the train set
colname_diff <-setdiff(colnames_trian_set,colnames_test_set)

#Selecting character columns
categorical_columns<- colnames(df %>% select(which(sapply(.,is.character))))
#Number of character columns
n_cat_cols <- length(categorical_columns)
#Display character columns in table

categorical_columns_tb <- matrix(categorical_columns,10,byrow=TRUE) %>%kable()%>%
  kable_material(c("striped"))%>% 
  kable_minimal()%>%
  add_header_above(c("Categorical Columns"=5))

#Selecting numeric data
numerical_columns<-colnames(df %>% select(which(sapply(.,is.numeric))))
#Number of Numeric Columns
n_numeric_columns <- length(numerical_columns)
#Display numeric columns in Table
numerical_columns_tb <- matrix(numerical_columns,10,byrow=TRUE) %>%kable()%>%
  kable_material(c("striped"))%>% 
  kable_minimal()%>%
  add_header_above(c("Numerical Columns"=4))
```
<p>Comparing amount of columns between each dataset we can see that we have 1 more column in the train set vs the test set.
**`r colname_diff`** is the additional column in the train set and our **target value** for this model
We going to use the train set to predict **`r colname_diff`** on the test, first we going to make some EDA and data cleaning.</p>

Total categorical columns: `r n_cat_cols`

`r categorical_columns_tb`  

Total numeric columns: `r n_numeric_columns`  

`r numerical_columns_tb`  
  
Im going to handle MSSubClass as categorical data although it is shown as numeric column, is actually a categorical data, the numbers is the columns are the type of dwelling involved in the sale, im removing from numeric columns and append as categorical.  
```{r, echo=FALSE, message=FALSE, warning=FALSE}
#Remove MSSubClass from numeric columns
numerical_columns <- numerical_columns[!(numerical_columns %in% c("MSSubClass"))]
#Append MSSubClass to categorical columns
categorical_columns<-append(categorical_columns,"MSSubClass")
```
## Missing Values
For this analysis we going to select just the columns that have missing values, **if they not in plot or table its because they not have missing values**.
```{r, echo=FALSE, message=FALSE, warning=FALSE}
#getting percentage of null values in each column
missing_values<- function(df){
nan_columns <- sort(colMeans(is.na(df)))
nan_summary<- data.table("name"= names(nan_columns),"prc_na"=nan_columns) %>% arrange(desc(prc_na)) %>% mutate(type= ifelse(name %in% categorical_columns,"categorical","numerical"))
  nan_summary}
nan_summary<- missing_values(df)  %>% filter(prc_na>0)
na_categorical <- nan_summary %>% filter(type=="categorical") %>% select(name,prc_na) %>%
  kable() %>%
  kable_styling(position = "left", full_width = FALSE) %>%
  column_spec(2, color = "white",
              background = spec_color(nan_summary$prc_na,option="B", end = 0.7))%>%
  kable_material(c("striped"))%>% 
  kable_minimal()%>%
  add_header_above(c("Missing Categorical Columns"=2))
  
  
na_numerical <- nan_summary %>% filter(type=="numerical") %>% select(name,prc_na)%>%
  kable() %>%
  kable_styling(position = "left", full_width = FALSE) %>%
  column_spec(2, color = "white",
              background = spec_color(nan_summary$prc_na,option="B", end = 0.7))%>%
  kable_material(c("striped"))%>% 
  kable_minimal()%>%
  add_header_above(c("Missing Numerical Columns"=2))


```
**Description of columns with Missing Values**:

  `r na_categorical` 

  `r na_numerical`

By looking in the data_description file, we can determine that we have columns that show us measurements, condition and qualities of additional features of the houses, They are defined with NA when they do not have one of them. To determine if they are really null values, we must compare multiple columns, example if we have NA PoolQC and PoolArea equal to 0 is the NA is not a Missing value, because the house doesnt have a pool, if PoolQC is NA but the PoolArea is greater than 0, we have a missing value.
</br> 

###   Identify associated columns 
```{r, echo=FALSE, message=FALSE, warning=FALSE}
df <-df[, order(names(df))]
#By looking in the description file, i bring columns that allow NA.
add_features <- c("Alley"
,"MasVnr"
,"Bsmt"
,"Fireplace"
,"Pool"
,"Heating"
,"Fence"
,"Misc"
,"Kitchen"
,"Exterior"
,"Garage")


#Create 3 empty values for save results
name_features<-NULL
dim_features <- NULL
dtype <-NULL
#set position in our lists
n <-0
#loop through our detected features
for ( f in add_features){
  #selecting columns that contains feature in name.
  f_df = df[,grepl(f, names(df))]
  num_cols =length(names(f_df))
  #check if there is true missing data.
  
   for(add_f in names(f_df)){
    n = n+1
    if(add_f %in% categorical_columns){
      dtype[n] = "categorical"}
    else{dtype[n]="numeric"}
   
    name_features[n] = f 
    dim_features[n]= add_f
   }
  
    
}

#I created a temporal data table to display features and columns.  
temp_df <- data.table(name_features,dim_features,dtype)
temp_df %>% kable()%>% pack_rows(index = table(fct_inorder(temp_df$name_features) )) %>% 
  kable_styling() %>%
  add_header_above(c("Related Features"=3))
```
### Cleaning set of Quality|Condition|Type where Area or SqrtFeet =0 (Max set of 2 columns)
This step we going to select most obvious **not** null values, features that have 1 or two columns to replace null values.
Where we have for example null in Quality or condition Column and 0 in Area or Square feet, we going to replace null values to "None Feature Value".
    
    - MasVnr
    - Pool
    - Fireplace
    - Fence
    - Alley
    
```{r, echo=FALSE, message=FALSE, warning=FALSE}
rm(temp_df)
df<- df %>% mutate(
          PoolQC = ifelse(is.na(PoolArea)|PoolArea==0,"No Pool",PoolQC),
          FireplaceQu = ifelse(is.na(Fireplaces)|Fireplaces==0,"No Fireplace",FireplaceQu),
          Alley = ifelse(is.na(Alley),"None Alley",Alley),
          Fence = ifelse(is.na(Fence),"None Fence",Fence),
          MasVnrType = ifelse(MasVnrArea==0|is.na(MasVnrArea), "None MasVnr",MasVnrType)
         )
```
</br>
After replacing, as result we still having null values, for those features that are keeping null values we going to take another approach for each one.
`r missing_values(df[grepl("MasVnr|Pool|Fire|Fence|Alley",names(df))]) %>% kable()%>% kable_styling() `

### Masonry veneer

Columns:

    1. MasVnrType.
    2. MasVnrArea.
</br>    
```{r, message=FALSE, warning=FALSE, echo=FALSE}

MasVnr_temp <- df  %>% filter(MasVnrType!="None MasVnr")

grid.arrange(
      grid.arrange(  MasVnr_temp %>%  ggplot() +
                    geom_bar(aes(y=MasVnrType))
                   ,MasVnr_temp %>% 
                    ggplot(aes(x=MasVnrType,y=MasVnrArea)) +
                    geom_boxplot() +
                    stat_summary(fun=mean,geom="point")+
                    coord_flip()
                    ,ncol = 2, nrow = 1),
       MasVnr_temp %>% group_by(YearBuilt,MasVnrType) %>% dplyr::summarise(count_=n()) %>%
         ggplot(aes(x=YearBuilt,y=count_,col=MasVnrType)) + 
        geom_line()+
        theme(legend.justification = c(0,1),
              legend.position = c(0,1),
        axis.text.x = element_text(angle = 90, vjust = 0.5)) +
        scale_x_continuous(breaks=seq(min(MasVnr_temp$YearBuilt),max(MasVnr_temp$YearBuilt),5)),
      heights=c(1/3, 2/3)
)

```
</br>
This plot show us between 1950 and 2005 BrkFace was the predominant type of MasVnr and after 2005 was Stone, we going to get the mode in every yearn and fill Na values with mode by year and look how many null values we get.
```{r, echo=FALSE, message=FALSE, warning=FALSE}
mode_masvnr <- MasVnr_temp   %>% group_by(YearBuilt) %>% dplyr::summarise(t_mode =mode(MasVnrType))
df<- df %>% left_join(mode_masvnr,  by="YearBuilt") %>%
  mutate(MasVnrType = ifelse(is.na(MasVnrType),t_mode,MasVnrType))%>%
  select(-t_mode) %>%
  mutate(MasVnrArea=ifelse(MasVnrType=="None MasVnr",0,MasVnrArea))
rm(MasVnr_temp)
missing_values(df[grepl("MasVnr",names(df))])  %>% kable()%>%
  kable_styling() %>%
  add_header_above(c("Mansory Veneer"=3))

```
```{r}

```


### Basement 

If TotalBsmtSF ==0 replace null with No basment in:

    - Exposure
    - Quality
    - FullBath
    - HalfBat  
</br>
If BsmntFinSF 1 & 2== 0, replace null with no BsmntFinType#

    - BsmtFinSF 1 & 2
```{r, warning=FALSE,message=FALSE, echo=FALSE}

df <- df %>% mutate(BsmtFinType1 = ifelse(BsmtFinSF1==0, "No Basment 1", BsmtFinType1),
             BsmtFinType1 = ifelse(BsmtFinSF2==0, "No Basment 2", BsmtFinType2),
             BsmtCond = ifelse(TotalBsmtSF==0, "No Basment", BsmtCond),
             BsmtQual = ifelse(TotalBsmtSF==0, "No Basment", BsmtQual),
             BsmtExposure = ifelse(TotalBsmtSF==0, "No Basment", BsmtExposure),
             BsmtFullBath = ifelse(TotalBsmtSF==0, 0, BsmtFullBath),
             BsmtHalfBath = ifelse(TotalBsmtSF==0, 0, BsmtHalfBath)
)

             

missing_values(df[grepl("Bsmt",names(df))]) %>% kable()%>%
  kable_styling() %>%
  add_header_above(c("Basement"=3))

```
